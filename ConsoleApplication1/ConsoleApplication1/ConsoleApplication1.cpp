/* Filename: LexicalAnalyzer.cpp
CSC 340 - Programming Languages
Evan Mau [10265997]

A lexical analyzer system for simple arithmetic expressions.

Operator/keyword: +, -, * /, (, )
Identifer: (a+b+...+z+A+B+...Z)(a+b+...+z+A+B+...Z+0+1+2+...+9)*
Integer: (0+1+2+...+9)(0+1+2+...+9)*

*/

#include <iostream>
#include <fstream>
#include <cctype>
using namespace std;

/* Global declarations */
/* Variables */

int charClass;
char lexeme[100];
char nextChar;
int lexLen;
int token;
int nextToken;
int error = 0;
ifstream in_fp("syntax.txt");

/* Function declarations */
void getChar();
void addChar();
void getNonBlank();
int lex(); // to get the nextToken
void term();
void expr();
void factor();
void assign();


/* Character classes */
#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99

/* Token codes */
#define INT_LIT 10
#define IDENT 11
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26
#define MOD_OP 30
#define ASSIGN_OP 31
#define SEMICOLON 32

/******************************************************/
/* main driver */
int main()
{
	/* Open the input data file and process its contents */

	if (in_fp.fail())
	{
		cout << "File could not be opened\n";
		cin.get();
		exit(1);
	}
	else {
		getChar();

		lex();  // Getting the nextToken
		assign(); //non-terminal

	
				if (error == 0)
					cout << "***Goodjob 1 - Succeeded 0 - Failed*** \n";
				else
					cout << "*** BAD 0 - Succeeded " << error << " failed *** \n";
			}
	in_fp.close();

	system("PAUSE");

	return 0;
}

/*****************************************************/
/* lookup - a function to lookup operators and parentheses
and return the token */
	int lookup(char ch) {
	switch (ch) {
	case '(':
		addChar();
		nextToken = LEFT_PAREN;
		break;
	case ')':
		addChar();
		nextToken = RIGHT_PAREN;
		break;
	case '+':
		addChar();
		nextToken = ADD_OP;
		break;
	case '-':
		addChar();
		nextToken = SUB_OP;
		break;
	case '*':
		addChar();
		nextToken = MULT_OP;
		break;
	case '/':
		addChar();
		nextToken = DIV_OP;
		break;
	case '%':
		addChar();
		nextToken = MOD_OP;
		break;
	case '=':
		addChar();
		nextToken = ASSIGN_OP;
		break;
	case ';':
		addChar();
		nextToken = SEMICOLON;
		break;
	default:
		addChar();
		nextToken = EOF;
		break;
	}
	return nextToken;
}
/*****************************************************/
/* addChar - a function to add nextChar to lexeme */
void addChar() {
	if (lexLen <= 98) {
		lexeme[lexLen++] = nextChar;
		lexeme[lexLen] = 0;
	}
	else
		cout << " ***Error #6 - lexeme is too long*** \n";
	error++;
}
/*****************************************************/
/* getChar - a function to get the next character of
input and determine its character class */
void getChar() {
	in_fp.get(nextChar);
	if (in_fp.eof())   // if no more character in the file
		nextChar = EOF;

	if (nextChar != EOF) {
		if (isalpha(nextChar))
			charClass = LETTER;
		else if (isdigit(nextChar))
			charClass = DIGIT;
		else charClass = UNKNOWN;
	}
	else
		charClass = EOF;
}
/*****************************************************/
/* getNonBlank - a function to call getChar until it
returns a non-whitespace character */
void getNonBlank() {
	while (isspace(nextChar))
		getChar();
}
/***************************************************** /
/* lex - a simple lexical analyzer for arithmetic
expressions */
int lex() {
	lexLen = 0;
	getNonBlank();
	switch (charClass) {
		/* Parse identifiers */
	case LETTER:
		addChar();
		getChar();
		while (charClass == LETTER || charClass == DIGIT) {
			addChar();
			getChar();
		}
		nextToken = IDENT;
		
		break;
		/* Parse integer literals */
	case DIGIT:
		addChar();
		getChar();
		while (charClass == DIGIT) {
			addChar();
			getChar();
		}
		nextToken = INT_LIT;
		break;
		/* Parentheses and operators */
	case UNKNOWN:
		lookup(nextChar);
		getChar();
		break;
		/* EOF */
	case EOF:
		nextToken = EOF;
		lexeme[0] = 'E';
		lexeme[1] = 'O';
		lexeme[2] = 'F';
		lexeme[3] = 0;
		break;
	} /* End of switch */
	cout << " Next token is: " << nextToken
		<< "       Next lexeme is " << lexeme << "\n";
	return nextToken;
} /* End of function lex */

/*******************************************************************
Operator/keyword: +, -, * /, (, )
Identifer: (a+b+...+z+A+B+...Z)(a+b+...+z+A+B+...Z+0+1+2+...+9)*
Integer: (0+1+2+...+9)(0+1+2+...+9)*

The Extended Backus-Naur Form (EBNF) is:

<expr> -> <term> {(+| -) <term>}
<term> -> <factor> {(*| / ) <factor>}
<factor>-> id | int_constant | (<expr>)
*******************************************************************/


/* Function expr
Parses strings in the language
generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
	/* Parse the first term */
	term();
	/* As long as the next token is + or -, call
	lex to get the next token and parse the
	next term */

	while (nextToken == ADD_OP ||
		nextToken == SUB_OP) {
		lex(); // to get the nextToken
		term();
	}
}


/* term
Parses strings in the language generated by
the rule:
<term> -> <factor> {(* | /| %) <factor>}
*/
void term()
{
	/* Parse the first factor */
	factor();
	/* As long as the next token is * or /,
	next token and parse the next factor */

	while (nextToken == MULT_OP ||
		nextToken == DIV_OP || nextToken == MOD_OP)
	{
		lex();
		factor();
	}
} /* End of function term */


/* Function factor
Parses strings in the language generated by the
rule: <factor> -> id | int_constant |( <expr>) */
void factor()
{
	/* Determine which RHS */
	if (nextToken == IDENT)
		lex();
	else if
		(nextToken == INT_LIT)

		lex();

	else if (nextToken == LEFT_PAREN)
	{
		lex();
		expr();
		if (nextToken == RIGHT_PAREN)
			lex();
		else {
			cout << "*** Error #2 Missing RIGHT_PAREN \n";
			error++;
		}

	}  /* End of else if (nextToken == ...  */
	else {
		cout << "*** Error #1 *** \n"; /* Neither RHS matches */
		error++;
	}
} //<assign>->id = <expr>; {<assign>}
void assign() 
{
	if (nextToken == IDENT)
	{
		lex();
		if (nextToken == ASSIGN_OP)
		{
			lex();
			expr();
			if (nextToken == SEMICOLON)
				lex();
			else
			{
				cout << "*** Error #5 Missing Semicolon *** \n"; /* Neither RHS matches */
				error++;
			}
		}
		else
		{
			cout << "*** Error #4 Missing an Assignment *** \n"; 
			error++;
		}

	}
	else
	{
		cout << "*** Error #3 Must contain ID *** \n";
		error++;
	}
}

